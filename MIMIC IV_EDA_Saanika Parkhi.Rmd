---
title: "EDA: MIMIC-IV Clinical Database"
author: "Saanika Parkhi"
date: "2025-08-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

------------------------------------------------------------------------

#### **Introduction**

The **MIMIC-IV Clinical Dataset Demo v2.2** is a deidentified subset of intensive care electronic health records from the Beth Israel Deaconess Medical Center. Though limited to 100 patients, it preserves the full relational structure of MIMIC-IV, making it a practical resource for building analysis workflows and exploring the potential of real-world clinical data.

This dataset contains rich, multi-dimensional clinical information spanning demographics, admissions, intensive care unit (ICU) stays, laboratory test results, vital signs, medications, procedures, and outcomes. Because of its relational design, it enables researchers to explore health data across multiple levels: patient-level demographics, hospitalization-level events, and ICU-level data.

The objective of this project is to conduct a broad exploratory and inferential analysis, with the specific goals being:

-   Perform univariate and multivariate analyses to characterize patient populations, hospitalizations, and outcomes.

-   Explore relationships across multiple variables (e.g., age, sex, icu stays, and outcomes).

-   Formulate and test several clinically meaningful hypotheses, such as differences in length of stay across subgroups and associations between lab results and mortality

-   Evaluate data quality and completeness, while highlighting the challenges of working with real-world clinical data.

-   Visualize key patterns and associations through clear, reproducible plots and tables.

By adopting this approach, the project seeks to demonstrate how EHR data can be harnessed for both descriptive and inferential insights, showcasing the potential of MIMIC-IV for broader research in critical care, health outcomes, and medical decision-making. The Google R Style guide will be used.

------------------------------------------------------------------------

#### **Section One: Importing Data and Creating a Full Dataset**

<br>

##### **1. Loading Relevant Modules**

```{r modules, message=FALSE, warning=FALSE, results=FALSE}
(library(skimr))
(library(dplyr))
(library(tidyr))
(library(ggplot2))
```

<br>

##### **2. Importing Data Tables**

The data tables were downloaded from the Kaggle website: <https://www.kaggle.com/datasets/montassarba/mimic-iv-clinical-database-demo-2-2/data>. For this project, the following tables are selected for analysis from the MIMIC-IV dataset:

-   `patients.csv`: This table contains unique patient identifiers like `subject_id` along with demographic information such as gender and age. This will allow for individual-level demographic analysis and grouping based on certain patient characteristics.

- `omr.csv`: This table has information about each patient's weight, height, BMI and blood pressure (multiple entries per patient). Each patient is identified with a  `subject_id` and the time of measuring these characteristics is recorded as well.

-   `admissions.csv`: This table includes details about each hospital admission, the `hadm_id`, allowing me to differentiate between multiple admissions for the same patient. It also contains important contextual variables such as admission type, discharge status (including whether the patient died), insurance type, race, and marital status. These will allow me to conduct demographic and outcome-based comparisons.

-   `diagnoses_icd.csv`: This table included diagnostic information for each patient during their visit, containing the `subject_id` and `hadm_id`. This table only contains `icd_code` correspnding to a specific diagnosis. For finding the description/name of the diagnosis itself, the table `d_icd_diagnoses` was used.

-   `pharmacy.csv`: This table includes information about the medications administered to each patient during their stay, thus containing both the `subject_id` and `hadm_id`. The start and stop times of the medication along with whether it expired, became inactive or was discontinued due to any reason is also included.

-   Lastly, `icustays.csv`: This table contains information on ICU-specific admissions, including the first and last care units and the length of stay in the ICU. This is useful for looking at more intensive and critical care patterns which I was interested in analyzing, and for comparing ICU vs. non-ICU patients. Additionally, this table can be linked using `subject_id` and `hadm_id`.

```{r data import, results = FALSE}

# Reading in the raw data files using "read.csv()"
patients_raw <- read.csv("patients.csv")
omr_raw <- read.csv("omr.csv")
admissions_raw <- read.csv("admissions.csv")
diagnoses_icd_raw <- read.csv("diagnoses_icd.csv")
diagnoses_reference_raw <- read.csv("d_icd_diagnoses.csv")
pharmacy_raw <- read.csv("pharmacy.csv")
icustays_raw <- read.csv("icustays.csv")


# Viewing the top entries in all tables 
head(patients_raw)
head(omr_raw)          
head(admissions_raw)
head(diagnoses_icd_raw)
head(diagnoses_reference_raw)
head(pharmacy_raw)
head(icustays_raw)           
```
All tables are loaded properly in R, and top entries look fine.

```{r working copy}
# Making working copies to not overwrite the original data 
patients <- patients_raw
omr <- omr_raw
admissions <- admissions_raw
diagnoses <- diagnoses_icd_raw
diagnoses_ref <- diagnoses_reference_raw
pharmacy <- pharmacy_raw
icustays <- icustays_raw

```

<br>

##### **3. Basic Data Skimming**

Before transforming or linking tables, a basic data quality check is conducted to view the data types, number of rows, and look for any NA values. The `skim()` function from `skimr` is used for inspecting the data thoroughly. 

```{r skim, results = FALSE} 

# Skimming the datasets using the `skim()` function
skim(patients) #number of rows = 100 (100 patients) 
               #character type columns = 3; numeric type columns = 3 
               #n_missing = 0 and complete_rate = 1 for all columns, meaning no NA values

skim(omr)      #number of rows = 2964 (2964 entries) 
               #character type columns = 3; numeric type columns = 2 
               #n_missing = 0 and complete_rate = 1 for all columns, meaning no NA values

skim(admissions)   #number of rows = 275 (275 admissions)
                   #character type columns = 13; numeric type columns = 3
                   #n_missing = 0 and complete_rate = 1 for all columns, meaning no NA values

skim(diagnoses)  #number of rows = 4506 (4506 diagnoses)
                 #character type columns = 1; numeric type columns = 4
                 #complete_rate = 1 for all columns, meaning no NA values

skim(diagnoses_ref)  #number of rows = 109775 (109775 reference diagnoses)
                     #character type columns = 2; numeric type columns = 1
                     #complete_rate = 1 for all columns, meaning no NA values

skim(pharmacy)    #number of rows = 15306 (15306 medications)
                  #character type columns = 16; numeric type columns = 9; logical type = 2
                  #8 columns have complete rate <1, with 2 of them (expirationdate and fill_quantity) having complete rate = 0 (all missing values); do not include these columns when subsetting data for analysis

skim(icustays)    #number of rows = 140 (140 icu stays)
                  #character type columns = 4; numeric type columns = 4
                  #complete_rate = 1 for all columns, meaning no NA values


```
*Note: Although some identifier columns like`subject_id` and `hadm_id` are stored as integers, they represent identifiers rather than numeric values. However, as their data types are consistent across the tables being joined, it is not necessary to convert them for the merging the tables. They will be converted later only if necessary.*

The `pharmacy` dataset has columns with many missing values and repeated medications for the same patient during the same admission. The `select()` function from `dplyr` will be used to subset specific columns, while the `distinct()` function will be used to extract only unique values. 

```{r subsetting pharmacy, results = FALSE} 

pharmacy <- pharmacy %>%
  select(subject_id, hadm_id, medication)  #keeping only relevant columns

pharmacy <- pharmacy %>%
  filter(medication != "") %>%       #there are a lot of empty strings for `medication`; filtering them out 
  distinct(subject_id, hadm_id, medication, .keep_all = TRUE)    #keeping only distinct medications per patient per admission

```
<br>

##### **4. Checking for Duplicates**

Before linking the datasets, it is important to confirm that the primary key columns are all unique values. This will ensure that any analysis or joins behave as intended and do not unintentionally inflate the number of rows due to any duplicate keys.

The following columns will be checked for duplicates:

- `subject_id` in `patients`dataset: there should be only one row per patient 
- `hadm_id` in `admissions` dataset: every patient admission should have a unique hospital admission number 
- `icd_code`in `diagnoses_ref` dataset: each diagnosis should have a unique icd code associated with it
- `stay_id` in `icustays` dataset: each stay in the ICU needs to have a unique id 

If duplicates are found where there should only be one record per ID, it may indicate data quality issues that need to be addressed before any sort of analysis.

```{r duplicates}

# Counting the number of duplicate ids above in each dataset to verify uniqueness

patients$subject_id %>%    
  duplicated() %>% 
  sum()                       #checking if `subject_id` is unique in `patients`

admissions$hadm_id %>%     
  duplicated() %>%
  sum()                       #checking if `hadm_id` is unique in `admissions`

diagnoses_ref$icd_code %>%     
  duplicated() %>% 
  sum()                       #checking if `icd_code` is unique in `diagnoses_ref`

icustays$stay_id %>%       
  duplicated() %>% 
  sum()                       #checking if `stay_id` is unique in `icustays`
```
As seen, all identifier values are unique in the datasets, except one: the `icd_code` in the `diagnoses_ref` has 493 duplicates and this dataset needs to be further inspected before joining with any other table.

```{r diagnoses reference duplicate}


# Filtering only the duplicated rows on `icd_code`, keeping the first and any later occurrences 
duplicate_diagnoses <- diagnoses_ref[duplicated(diagnoses_ref$icd_code) | 
                               duplicated(diagnoses_ref$icd_code, fromLast = T), ]

# Ordering by `icd_code` to see duplicate entries together 
head(duplicate_diagnoses[order(duplicate_diagnoses$icd_code), ])

# Checking whether there are duplicates based on the composite key of both`icd_code` and `icd_version`
sum(duplicated(diagnoses_ref[, c("icd_code", "icd_version")]))    #returns 0

```
Although the `icd_code` values appear more than once in the `diagnoses_ref` table, these are not true duplicates as all the duplicated codes differ based on the `icd_version` column. Therefore, the combination of `icd_code` and `icd_version` together can form a composite key that uniquely identifies each diagnosis reference entry.

Additionally, `omr` dataset has multiple entries for a single patient id for `Height`, `Weight` and `BMI`. To look at how patient demographics affect hospital stays and health outcomes, the decision was made to create aggregate columns so only the average values are kept per patient.

```{r aggregate omr}

omr_wide <- omr %>%
  filter(result_name %in% c("Height (Inches)", "Weight (Lbs)", "BMI (kg/m2)")) %>%      #choosing only the relevant values 
  select(subject_id, result_name, result_value) %>%        
  pivot_wider(                            #to keep only one entry per patient
    names_from = result_name,
    values_from = result_value,
    values_fn = ~ mean(as.numeric(.x), na.rm = TRUE)     #to summarise the multiple entries; the average of the values is taken
  ) %>%
  rename(
    Height = `Height (Inches)`,
    Weight = `Weight (Lbs)`,
    BMI = `BMI (kg/m2)`
  )

omr_wide     #some NA values are seen, but those will be kept for now

```
<br>


##### **5. Data Linking**

The `diagnoses` and `diagnoses_ref` will first be joined to add the name of the diagnosis to the corresponding code, using both the `icd_code` and `icd_version` due to duplicated `icd_code` values. A `left_join()` is done to only keep the diagnoses for patients (not all diagnosis names).

```{r data linking diag}

diagnoses_full <- left_join(diagnoses, diagnoses_ref, by = c("icd_code", "icd_version"))
diagnoses_full     #there are multiple diagnoses for each patient even for a single hospital admission, `seq_num` gives pseudo-order for icd codes with 1 being most relevant diagnosis

# Keeping only the primary diagnosis per patient per admission
primary_diagnosis <- diagnoses_full %>%
  filter(seq_num == 1)     #only most relevant diagnosis is taken 

primary_diagnosis
```

First, the `omr` and `patients` datasets will be linked by `subject_id` to add information about height, weight and BMI to each patient. A `full_join()` is done to keep all entries.

Next, the `admissions` dataset will be joined by `subject_id` to add demographic information to each hospital admission. As a single patient can have multiple admissions, the `left_join()` function is used to keep all the admissions.

Then, the `primary_diagnosis` table will be joined on both `subject_id` and `hadm_id` to ensure accurate matching of the diagnostic information and admission information. A `full_join()` is done to keep all entries.

Next, the `pharmacy` table will be joined on both `subject_id` and `hadm_id` to ensure accurate matching of the diagnostic information and admission information. A `left_join()` is done to keep all admissions and corresponding pharmacy data.

Lastly, the resulting table will joined with the `icustays` table on both `subject_id` and `hadm_id` to ensure accurate matching of ICU stay data to the correct admission and patient. A `left_join()` is used to make sure all admissions are kept even if that admission did not involve an ICU stay.
```{r data linking, warning = FALSE}

omr_patients <- full_join(omr_wide, patients, by = "subject_id")    #joining `omr` and `patients`

admissions_omr_patients <- left_join(admissions, omr_patients, by = "subject_id")    #joining `admissions` to previous table

admissions_omr_patients_diagnoses <- full_join(primary_diagnosis, admissions_omr_patients, by = c("subject_id", "hadm_id"))       #joining `primary_diagnosis` to previous table

admissions_omr_patients_diagnoses_pharmacy <- left_join(admissions_omr_patients_diagnoses, pharmacy, by = c("subject_id", "hadm_id"))   #joining `pharmacy` to previous table

complete_data <- left_join(admissions_omr_patients_diagnoses_pharmacy, icustays, by = c("subject_id", "hadm_id"))   #joining `icustays` to previous table

# Viewing the complete dataset
View(complete_data)

```

----------------------------------------------------------------------------------------------------

### **Section Two: Data Quality Checks**

<br>


##### **1. Overall Data Check**

The `skim()` function is used here again as it provides a concise summary of each variable, including data type, number of missing values, and completeness rate. The data will also be inspected manually with the "View()" function to get an overall sense of what data quality checks need to be done.
```{r skim2, results=FALSE}
skim(complete_data)   #OMR data is missing for some entries and as expected, some ICU-related columns now contain NA values for admissions that did not involve an ICU stay
                      #character type columns = 23; numeric type columns = 12

View(complete_data)   #several character type columns have missing values represented in ways other than `NA`
```
*Finding: While many columns, especially those unrelated to ICU data, do not contain explicit `NA` values, missing data is still present in alternative forms. For example, the `race` column uses "UNKNOWN" or "UNABLE TO OBTAIN" to indicate missing values, the `language` column uses "?", and several other columns use empty strings. These need to be cleaned up to reflect missing values properly.*

<br>

##### **2. Standardizing Missing Values**

The dataset will be cleaned by standardizing how missing values are represented. Although some missing values are already coded as `NA`, others are represented using placeholders such as "UNKNOWN", "?", or empty strings "". These inconsistent representations can lead to incorrect summaries or misleading results during analysis if not handled properly. 

First, a function called `clean_missing()` will be created to replace the different placeholder values with actual `NA` values for consistency and easier handling.

```{r clean missing}

clean_missing <- function(x) {
  if (is.character(x)) {                                         #only character type columns were found to have these placeholder values
    x[x %in% c("UNKNOWN", "?", "", "UNABLE TO OBTAIN")] <- NA    #the placeholder value is replaced with `NA`
  }
  return(x)                                                      #`NA` is returned if there was a placeholder value, otherwise the original value is returned
}
```

The function `mutate()` from `dplyr` will be used to modify the columns. The `clean_missing()` function will then be applied to each and every column using `across(everything())` to clean all of the missing values and standardize them to `NA`. 

```{r clean missing apply}

complete_data <- complete_data %>%
  mutate(across(everything(), clean_missing))

View(complete_data)   #all missing or placeholder values are replaced with `NA`

```

<br>

----------------------------------------------------------------------------------------------------

### **Section Three: Exploring Patient Demographics and Distributions**

To better understand trends across the patient population, distributions will be analyzed based on key demographic and health-related variables. I have chosen to include `age`, `gender`, `BMI`, and `race`. These factors can offer insights into patient outcomes, inequities, and hospital resource allocation. The function `ggplot()` from `ggplot2` will be used to construct the graphs. 

First, a `patients_unique` dataset will be created to keep only one entry per patient for exploring patient characteristics. 

```{r missing hadm_id, results = FALSE}

table(complete_data$hadm_id, useNA = "ifany")   #confirming that no patients in the dataset are missing `hadm_id`; none do so all patients in `patients` table were admitted and that dataset can be used directly for EDA 

patients_unique <- complete_data %>%
  distinct(subject_id, .keep_all = TRUE)   #the argument keep_all is set to TRUE to keep all columns 

```

<br>


##### **2. Patient Age Distribution**

Age is a fundamental demographic variable that often correlates with multiple admissions, health outcomes, and hospital length of stay. Understanding the distribution of patient age can help identify whether the dataset reflects a particular population (e.g., elderly ICU patients or younger trauma patients). A histogram is used to plot the data as `age` is continuous (numerical) variable.

```{r age distribution}
ggplot(patients_unique, aes(x = anchor_age)) +
  geom_histogram(binwidth = 5, fill = "darkgreen", color = "black") + 
  labs(title = "Age Distribution of Patients", x = "Age", y = "Number of Patients")
```
The histogram shows that most patients in the dataset are older adults, with a noticeable concentration between ages 60 and 75. The distribution appears slightly right-skewed, with relatively fewer younger patients compared to older individuals.A few younger patients (<30 years old) are present, but they are underrepresented compared to the older population

<br>


##### **2. Patient Gender Distribution**

Gender is a key demographic variable often associated with differences in treatment decisions and healthcare outcomes. Understanding the gender distribution provides insight into whether it reflects a balanced patient population or is skewed toward a particular sex. As `gender` is categorical, a bar chart is used to visualize the count of patients by gender.

```{r gender distribution}

ggplot(patients_unique, aes(x = gender)) +   
  geom_bar(stat = "count", fill = "darkgreen", color = "black") +
  labs(title = "Gender Distribution of Patients", x = "Gender", y = "Count")

```
The barplot shows that the dataset has a slightly higher number of male patients compared to female patients. However, the counts of both seem pretty balanced as both are close to 50. This indicates that the distribution is quite balanced.

<br>

##### **3. Patient BMI Distribution**

BMI is a key indicator of patient health and can help categorize individuals as underweight, normal weight, overweight, or obese, which can have direct implications for predicting hospital length of stay or complication rates. `BMI` is a continuous variable and thus visualized here using a histogram.

```{r bmi distribution}

ggplot(patients_unique, aes(x = BMI)) +
  geom_histogram(binwidth = 3, fill = "darkgreen") +
  labs(title = "BMI Distribution", x = "BMI", y = "Density")

```
There seems to be some outliers that are greater than BMI of 600, which is an implausible value. The BMI values need to be explored further. 

```{r BMI range fix}

patients_unique %>%
  arrange(desc(BMI))     #the highest BMI recorded is 686.9, which is significantly higher than the next highest value (41.47); it is treated as an outlier and is removed 

patients_unique <- patients_unique %>%
  filter(BMI < 100)   #removing the outlier values

complete_data <- complete_data %>%
  filter(BMI < 100)   #removing outliers from the full dataset

```

```{r bmi distribution}

ggplot(patients_unique, aes(x = BMI)) +
  geom_histogram(binwidth = 3, fill = "darkgreen", color = "black") +
  labs(title = "BMI Distribution of Patients", x = "BMI", y = "Density")

```
The histogram shows that the majority of patients have a BMI between 20 and 35, which roughly corresponds to the normal and overweight ranges. There is a visible peak around 26â€“28, suggesting that overweight individuals form a substantial part of the dataset.

<br>

##### **4. Patient Race Distribution**

Race is a key demographic variable that can influence health disparities, access to care, and clinical outcomes. Understanding the racial composition of the patient population helps assess the representativeness of the dataset and identify potential biases. The variable `race` is categorical so a barplot is used for visualization.

```{r race distribution}

ggplot(patients_unique, aes(x = race)) +   
  geom_bar(stat = "count", fill = "darkgreen", color = "black") +
  labs(title = "Race Distribution of Patients", x = "Race", y = "Count") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

```
The majority of patients in the dataset identify as White, with a few individuals representing other racial groups such as Black/African American, Hispanic/Latino, and Portuguese. Several categories are sparsely populated, and some patients either declined to answer or had missing data. This indicates a lack of racial diversity in the sample, which may limit generalizability of analyses across different populations.

<br> 

##### **5. Summary of Patient Characteristics**

This EDA of the `patients` dataset focused on key demographic variables such as `age`, `gender`, `BMI`, and `race`, as these are commonly associated with clinical outcomes, including ICU admissions, hospital length of stay, and mortality. Visualizations showed that the dataset primarily includes older adults (>30 years old), with a slightly higher proportion of male patients and mainly those identifying as White.

Only `age`, `gender`, and `BMI` will be used for further analysis as these variables showed meaningful variability across the patient population. In contrast, `race` showed limited distribution, reducing its utility for deeper comparative or statistical analysis.

<br>

----------------------------------------------------------------------------------------------------

### **Section Four: Impact of Patient Demographics on Clinical Course and Outcomes**

In this section, we will analyze how the selected patient characteristics, namely age, BMI and gender, are associated with clinical outcomes such as diagnoses, medication use, hospital stay length, ICU stay length, and in-hospital mortality. This is done to see whether patient demographics have any influence on the length of stay, clinical services and patient outcomes in this dataset. Understanding such associations helps uncover patterns in healthcare utilization, identify potential disparities in outcomes, and inform clinical decision-making and policy development.

<br>

##### **1. Creating a Derived Variable for BMI Categories**

First, BMI is categorized into standard clinical weight groups. This is done to allow for stratified comparisons, as BMI has shown to be linked with an increased risk of chronic diseases and helps guide treatment decisions. The classifications are done based on the values given by Diabetes Canada: https://www.diabetes.ca/resources/tools-resources/body-mass-index-(bmi)-calculator. Obese classification was not broken down further as the counts became too low for meaningful comparison. 

```{r bmi cat}
complete_data$BMI_Category <- ifelse(complete_data$BMI < 18.5, "Underweight",
                                ifelse(complete_data$BMI < 25, "Normal",
                                ifelse(complete_data$BMI < 30, "Overweight", "Obese"
                                )))


# Converting to ordered factor for meaningful comparison
complete_data$BMI_Category <- factor(complete_data$BMI_Category,
                                       levels = c("Underweight", "Normal", "Overweight", "Obese"),
                                       ordered = TRUE)

# Updating the `patients_unique` dataset
patients_unique <- complete_data %>%
  distinct(subject_id, .keep_all = TRUE)   

# Checking the distribution
table(patients_unique$BMI_Category)  #almost an even distribution of normal, overweight and obese patients in the dataset (but only 1 underweight patient)   
```
<br> 
